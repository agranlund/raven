//------------------------------------------------------------------------------
// Copyright Anders Granlund 2024-2025.
// This source describes Open Hardware and is licensed under the CERN-OHLW v2
// You may redistribute and modify this documentation and make products
// using it under the terms of the CERN-OHL-W v2 (https:/cern.ch/cern-ohl).
// This documentation is distributed WITHOUT ANY EXPRESS OR IMPLIED
// WARRANTY, INCLUDING OF MERCHANTABILITY, SATISFACTORY QUALITY
// AND FITNESS FOR A PARTICULAR PURPOSE.
// Please see the CERN-OHL-W v2 for applicable conditions.
//------------------------------------------------------------------------------
Name     Nessi ;
PartNo   00 ;
Date     2025-xx-xx ;
Revision 01 ;
Designer Anders Granlund ;
Company  HappyDaze ;
Assembly None ;
Location  ;
Device   f1508ispplcc84;

//------------------------------------------------------------------------------
// ATF1508AS-7JX84 : PLCC84, ISP, 7ns
//------------------------------------------------------------------------------
PROPERTY ATMEL{JTAG=on};
PROPERTY ATMEL{TDI_pullup=on};
PROPERTY ATMEL{TMS_pullup=on};
PROPERTY ATMEL{pd1=off};
PROPERTY ATMEL{pd2=off};
PROPERTY ATMEL{cascade_logic=off};
PROPERTY ATMEL{logic_doubling=off};
PROPERTY ATMEL{output_fast=on};
PROPERTY ATMEL{pin_keep=off};
PROPERTY ATMEL{preassign=keep};
PROPERTY ATMEL{security=off};
PROPERTY ATMEL{xor_synthesis=on};

//------------------------------------------------------------------------------
// todo:
//  - defines to build for different waitstates
//    currently adjusted for 48mhz bclk
//
// mhz   ns
//  32 = 31.25
//  40 = 25
//  48 = 20.83
//  50 = 20
//  64 = 15.625
//  80 = 12.5
//  96 = 10.416
// 100 = 10
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// JTAG reserved
//------------------------------------------------------------------------------
//pin 14 = ;                // JTAG_TDI
//pin 23 = ;                // JTAG_TMS
//pin 62 = ;                // JTAG_TCK
//pin 71 = ;                // JTACK_TDO

//------------------------------------------------------------------------------
// Global inputs
//------------------------------------------------------------------------------
pin 81 = SPARE_J106_IN_81;  // in:  unused J106
pin 83 = BCLK;              // in:  global clock x1
pin 84 = SPARE_J105_IN_84;  // in:  unused J105 (hi/lo jumpered)
pin 1  = !RSTI;             // in:  hardware reset in
pin 2  = BCLK2X;            // in:  global clock x2

//------------------------------------------------------------------------------
// I/O blocks
//------------------------------------------------------------------------------
pin 4  = !TA;               // out: cpu
pin 5  = !TEA;              // out: cpu
pin 6  = !AVEC;             // out: cpu
pin 8  = !TBI;              // out: cpu
pin 9  = !TCI;              // out: cpu
pin 10 = CPUX1;             // in:  option jumper: cpu 1x/2x mode
pin 11 = !TRA;              // out: cpu
pin 12 = CLKEN;             // out: cpu

pin 15 = TT1;               // in:  cpu 
pin 16 = TT0;               // in:  cpu
pin 17 = !TIP;              // in:  cpu
pin 18 = !TS;               // in:  cpu
pin 20 = TM1;               // in:  cpu
pin 21 = TM0;               // in:  cpu
pin 22 = TM2;               // in:  cpu

pin 24 = !SAS;              // in:  cpu
pin 25 = SIZ1;              // in:  cpu
pin 27 = SIZ0;              // in:  cpu
pin 28 = RW;                // in:  cpu
pin 29 = !CLA;              // out: cpu
pin 30 = A0;                // in:  cpu
pin 31 = A1;                // in:  cpu

pin 33 = A9;                // in:  cpu
pin 34 = A5;                // in:  cpu
pin 35 = A25;               // in:  cpu
pin 36 = A10;               // in:  cpu
pin 37 = A24;               // in:  cpu
pin 39 = A29;               // in:  cpu
pin 40 = A30;               // in:  cpu
pin 41 = A31;               // in:  cpu

pin 44 = !RB2RD;            // out: simm2
pin 45 = !RB2WR;            // out: simm2
pin 46 = !RB1RD;            // out: simm1
pin 48 = !RB1WR;            // out: simm1
pin 49 = !RB0RD;            // out: simm0
pin 50 = !RB0WR;            // out: simm0
pin 51 = !RB3RD;            // out: simm3
pin 52 = !RB3WR;            // out: simm3

pin 54 = !IOCS16;           // in:  ISA bus
pin 55 = !EXCS;             // out: 68150 (and transcievers)
pin 56 = !EXDSACK0;         // out: 68150
pin 57 = !EXTA;             // in:  68150
pin 58 = !EXDS;             // in:  68150
pin 60 = !EXDTACK;          // in:  MFP1, MPF2, Iksi
pin 61 = !EXDSACK1;         // out: 68150

pin 63 = !ISA8;             // out: Narnia
pin 64 = !ISAIO;            // out: Narnia
pin 65 = !ISACS;            // out: Narnia
pin 67 = !ISANOWS;          // in:  ISA bus
pin 68 = ISARDY;            // in:  ISA bus
pin 69 = !RESET;            // out: peripheral reset
pin 70 = !RSTO;             // in:  cpu

pin 73 = SPARE_J106_IO_73;  // xxx: unused J106 (io)
pin 74 = !IACK;             // out: MFP1, MFP2
pin 75 = !IDECS;            // out: Iksi
pin 76 = !YMCS;             // out: Iksi
pin 77 = !MFP2CS;           // out: MFP2
pin 79 = !MFP1CS;           // out: MFP1
pin 80 = !UARTCS;           // out: UART


//------------------------------------------------------------------------------
//
// General logic
//
//------------------------------------------------------------------------------
CLKEN = BCLK # CPUX1;       // generate cpu bclk
RESET = RSTI # RSTO;        // generate peripheral reset
TEA = 'b'0;                 // bus error
TRA = 'b'0;                 // bus retry


//------------------------------------------------------------------------------
//
// Interrupts
//  TT1:0 = 11
//  TM2:0 = IPL
//  A31:0 = $ffffffff
//
// Breakpoint
//  TT1:0 = 11
//  TM2:0 = 0
//  A32:0 = 00000000
//
// LPSTOP
//  TT1:0 = 11
//  TM2:0 = 0
//  A32:0 = $fffffffe
//
//------------------------------------------------------------------------------
IRQCYCLE    = [TT1..0]:'b'11;
BUSCYCLE    = [TT1..0]:'b'0X;
AUTOIRQ     = IRQCYCLE & ![TM2..0]:'b'110;  // autovector everything except mfp
MFPIRQ      = IRQCYCLE & [TM2..0]:'b'110;   // MFP = IRQ6
AVEC        = !MFPIRQ;


//------------------------------------------------------------------------------
//
// Memory map : 32bit
//
//------------------------------------------------------------------------------
DECODE_SIMM0        = [A31..0]:'b'000XXX00XXXXXXXXXXXXXXXXXXXXXXXX;    // $00000000
DECODE_SIMM1        = [A31..0]:'b'000XXX01XXXXXXXXXXXXXXXXXXXXXXXX;    // $01000000
DECODE_SIMM2        = [A31..0]:'b'000XXX10XXXXXXXXXXXXXXXXXXXXXXXX;    // $02000000
DECODE_SIMM3        = [A31..0]:'b'010XXX00XXXXXXXXXXXXXXXXXXXXXXXX;    // $40000000
DECODE_UART         = [A31..0]:'b'001XXX00XXXXXXXXXXXXXXXXXXXXXXXX;    // $20000000


//------------------------------------------------------------------------------
//
// Memory map : 16/8 bit
//
//------------------------------------------------------------------------------
DECODE_IDE          = [A31..0]:'b'101XXX00XXXXXXXXXXXXX00XXXXXXXXX;    // $A0000000
DECODE_MFP2         = [A31..0]:'b'101XXX00XXXXXXXXXXXXX01XXXXXXXXX;    // $A0000A00

DECODE_YM           = [A31..0]:'b'101XXX01XXXXXXXXXXXXX00XXXXXXXXX;    // $A1000800    ($ff8800)
DECODE_MFP1         = [A31..0]:'b'101XXX01XXXXXXXXXXXXX01XXXXXXXXX;    // $A1000A00    ($fffa00)
DECODE_ACIA         = [A31..0]:'b'101XXX01XXXXXXXXXXXXX10XXXXXXXXX;    // $A1000C00    ($fffc00)
DECODE_INV1         = [A31..0]:'b'101XXX01XXXXXXXXXXXXX11XXXXXXXXX;    // $A1000e00    ($fffe00)

DECODE_ISA_A_RAM8   = [A31..0]:'b'100XXX00XXXXXXXXXXXXXXXXXXXXXXXX;    // $80000000
DECODE_ISA_A_IO8    = [A31..0]:'b'100XXX01XXXXXXXXXXXXXXXXXXXXXXXX;    // $81000000
DECODE_ISA_A_RAM16  = [A31..0]:'b'100XXX10XXXXXXXXXXXXXXXXXXXXXXXX;    // $82000000
DECODE_ISA_A_IO16   = [A31..0]:'b'100XXX11XXXXXXXXXXXXXXXXXXXXXXXX;    // $83000000

BYTE_CYCLE          = (SIZ0 & !SIZ1);
BYTE_READ           = BYTE_CYCLE & RW;

DECODE_ISA_RAM8     = DECODE_ISA_A_RAM8 # (DECODE_ISA_A_RAM16 & BYTE_READ & !A0);
DECODE_ISA_RAM16    = DECODE_ISA_A_RAM16 & !DECODE_ISA_RAM8;

DECODE_ISA_IO16     = (DECODE_ISA_A_IO8 & !BYTE_CYCLE) # DECODE_ISA_A_IO16;
DECODE_ISA_IO8      = DECODE_ISA_A_IO8 & !DECODE_ISA_IO16;


DECODE_ISA          = DECODE_ISA_RAM8 # DECODE_ISA_IO8 # DECODE_ISA_RAM16 # DECODE_ISA_IO16;
DECODE_ISA16        = DECODE_ISA_IO16 # DECODE_ISA_RAM16;
DECODE_68150        = DECODE_IDE # DECODE_YM # DECODE_MFP1 # DECODE_MFP2 # DECODE_ISA;


//------------------------------------------------------------------------------
// Localbus
// For simplicity, all local devices share same bus timing at the moment.
// todo: may want to extend cs period for a more comfortable 60ns cycle.
//
//
//         0   1   2   3   4   5   6   7   8   
// BCLK:   |---|   |---|   |---|   |---|   |---
//         |   |___|   |___|   |___|   |___|
//
//            a                    b       c
// TIP:    ________________________|-----------
// TS:     ________|---------------------------
// SAS:    --------|_______|-------------------
// BRD:    ------------|___________|xxxxxxxx---  (~25) + 30 (+20 max hold)
// BWR:    ------------|___________|-----------
// TA:     --------------------|_______|-------
//
// (a) address and signals valid
// (b) cpu samples TA and ends cycle
// (c) trash remaining on databus ~20ns, clear before next SAS
//
//------------------------------------------------------------------------------

node [BSRD3..6];
[BSRD3..6].ar = RSTI;
[BSRD3..6].ck = BCLK2X;
BSRD3.d = (SAS & RW) & !BSRD3;  // cs
BSRD4.d = BSRD3;                // cs
BSRD5.d = BSRD4 & !BSRD3;       // cs ta
BSRD6.d = BSRD5 & !BSRD3;       //    ta

node [BSWR3..6];
[BSWR3..6].ar = RSTI;
[BSWR3..6].ck = BCLK2X;
BSWR3.d = (SAS & !RW) & !BSWR3; // cs
BSWR4.d = BSWR3;                // cs
BSWR5.d = BSWR4 & !BSWR3;       // cs ta
BSWR6.d = BSWR5 & !BSWR3;       //    ta

BUSTA = ((BSRD5 # BSRD6) # (BSWR5 # BSWR6));
BUSRD = (BSRD3 # BSRD4 # BSRD5);
BUSWR = (BSWR3 # BSWR4 # BSWR5);


//------------------------------------------------------------------------------
// RAM / ROM
// cycle time: 50ns
// oe/we time: 30ns
// hold time:  20ns
//------------------------------------------------------------------------------
node ROM_OVERLAY_DISABLED;
ROM_OVERLAY_DISABLED.ck = TS & RW & DECODE_SIMM3;
ROM_OVERLAY_DISABLED.ar = RSTI;
ROM_OVERLAY_DISABLED.d = 'b'1;

RB0RD = BUSRD & (DECODE_SIMM0 # DECODE_ACIA) & ROM_OVERLAY_DISABLED;
RB1RD = BUSRD & DECODE_SIMM1;
RB2RD = BUSRD & DECODE_SIMM2;
RB3RD = BUSRD & (DECODE_SIMM3 # (DECODE_SIMM0 & !ROM_OVERLAY_DISABLED));

RB0WR = BUSWR & DECODE_SIMM0;
RB1WR = BUSWR & DECODE_SIMM1;
RB2WR = BUSWR & DECODE_SIMM2;
RB3WR = BUSWR & DECODE_SIMM3;

DECODE_RAM = DECODE_SIMM0 /*# DECODE_ACIA*/ # DECODE_SIMM1 # DECODE_SIMM2;
DECODE_ROM = DECODE_SIMM3;

TCI = !(TIP & (DECODE_SIMM0 /*# DECODE_ACIA*/ # DECODE_SIMM1 # DECODE_SIMM2 # DECODE_SIMM3));
TBI = 'b'1; // burst inhibit
CLA = 'b'0; // burst address increment


//------------------------------------------------------------------------------
// UART
//------------------------------------------------------------------------------
UARTRD = BSRD4 # BSRD5;
UARTWR = BSWR4;
UARTCS = (UARTRD # UARTWR) & DECODE_UART;


//------------------------------------------------------------------------------
// Debug
//------------------------------------------------------------------------------
//SPARE_J106_IO_73 = !UARTCS;


//------------------------------------------------------------------------------
// MC68150 bus
//------------------------------------------------------------------------------
node [YMDTACK0..3];     // todo: shared waitstate counter
node [IDEDTACK0..5];
node ISADSACK0;
node ISADSACK1;

EXDSACK1 = EXDS & (
    EXDTACK #
    YMDTACK3 #
    IDEDTACK4 #
    ISADSACK1
    );

EXDSACK0 = EXDS & (
    ISADSACK0
    );

// todo: sample on SAS
// todo: double check cs release
SELECT_68150 = TIP & (DECODE_68150 # MFPIRQ);
EXCS.ck = BCLK;
EXCS.ar = RSTI;
EXCS.d = SELECT_68150 & !EXTA;


//------------------------------------------------------------------------------
// 68150 : IRQ
//------------------------------------------------------------------------------
IACK.ck = !BCLK;
IACK.ar = RSTI;
IACK.d = EXDS & EXCS & MFPIRQ;


//------------------------------------------------------------------------------
// 68150 : MFP
//------------------------------------------------------------------------------
MFP1CS.ck = !BCLK;
MFP1CS.ar = RSTI;
MFP1CS.d = EXDS & EXCS & DECODE_MFP1;

MFP2CS.ck = !BCLK;
MFP2CS.ar = RSTI;
MFP2CS.d = EXDS & EXCS & DECODE_MFP2;


//------------------------------------------------------------------------------
// 68150 : YM
//------------------------------------------------------------------------------
YMCS.ck = !BCLK;
YMCS.ar = RSTI;// # !EXDS;
YMCS.d  = EXDS & EXCS & DECODE_YM;

[YMDTACK0..3].ck = !BCLK;
[YMDTACK0..3].ar = RSTI # !YMCS # !EXDS;
YMDTACK3.d = YMDTACK2;
YMDTACK2.d = YMDTACK1;
YMDTACK1.d = YMDTACK0;
YMDTACK0.d = YMCS;


//------------------------------------------------------------------------------
// 68150 : IDE
//
// PIO  Cyc    Set    MB/s
// 0    600    70     3
// 1    383    50     5
// 2    240    30     8
// 3    180    20     11
// 4    120    14     16
// 5    100    12     20
// 6     80    10     25
//------------------------------------------------------------------------------

// Trigger IDE_CS early to comply with IDE_CS -> IDE_RW setup time
// todo: sample on TS, or half clock before SAS
IDECS.ck = BCLK;
IDECS.ar = RSTI;
IDECS.d  = SELECT_68150 & DECODE_IDE;

// IDE dtack delay counter
// todo: would be better to use the ready signal but
// only if we're in a PIO mode that supports it.
[IDEDTACK0..5].ck = !BCLK;
[IDEDTACK0..5].ar = RSTI # !IDECS # !EXDS;
IDEDTACK5.d = IDEDTACK4;
IDEDTACK4.d = IDEDTACK3;
IDEDTACK3.d = IDEDTACK2;
IDEDTACK2.d = IDEDTACK1;
IDEDTACK1.d = IDEDTACK0;
IDEDTACK0.d = IDECS & EXCS & EXDS;


//------------------------------------------------------------------------------
// 68150 : ISA
//------------------------------------------------------------------------------
node [ISADTACK0..20];

ISA8  = !DECODE_ISA16;
ISAIO = DECODE_ISA_IO8 # DECODE_ISA_IO16;
ISADS = EXCS & DECODE_ISA & EXDS;
ISACS = ISADS & ISADTACK1 & (RW # !ISADTACK19);

ISADSACK16 = DECODE_ISA_RAM16 # (DECODE_ISA_IO16 & IOCS16);
ISADSACKXX = ISADS & ISADTACK20;
ISADSACK1  = ISADSACKXX &  ISADSACK16;
ISADSACK0  = ISADSACKXX & !ISADSACK16;

node ISADONE;
ISADONE.ck = !BCLK;
ISADONE.ar = RSTI # !ISACS;
ISADONE.d = ISARDY; // # (!RW & !ISAIO);

[ISADTACK0..20].ck = !BCLK;
[ISADTACK0..20].ar = RSTI # !EXDS;
ISADTACK20.d = ISADTACK19;
ISADTACK19.d = ISADTACK18;
ISADTACK18.d = ISADTACK17;
ISADTACK17.d = (ISADTACK16 & ISADONE) # ISADTACK17;
ISADTACK16.d = ISADTACK15;
ISADTACK15.d = ISADTACK14;
ISADTACK14.d = ISADTACK13;
ISADTACK13.d = ISADTACK12;
ISADTACK12.d = ISADTACK11;
ISADTACK11.d = ISADTACK10 # (ISADS & DECODE_ISA_RAM16);
ISADTACK10.d = ISADTACK9;
ISADTACK9.d = ISADTACK8;
ISADTACK8.d = ISADTACK7;
ISADTACK7.d = ISADTACK6;
ISADTACK6.d = ISADTACK5;
ISADTACK5.d = ISADTACK4;
ISADTACK4.d = ISADTACK3;    // <--
ISADTACK3.d = ISADTACK2;
ISADTACK2.d = ISADTACK1;
ISADTACK1.d = ISADTACK0;
ISADTACK0.d = ISADS;


//------------------------------------------------------------------------------
// Bus cycle end
//------------------------------------------------------------------------------
TA = AUTOIRQ #              // autovector irq
    (EXCS & EXTA) #         // 68150 bus
    (!EXCS & BUSTA);        // local bus
